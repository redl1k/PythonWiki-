# Конструкция if/elif/else позволяет делать ответвления в ходе программы.

# Программа уходит в ветку при выполнении определенного условия.
#
# В этой конструкции только if является обязательным, elif и else опциональны:
#
# Проверка if всегда идет первой.
# После оператора if должно быть какое-то условие: если это условие выполняется (возвращает True),
# то действия в блоке if выполняются.
# С помощью elif можно сделать несколько разветвлений, то есть, проверять входящие данные на разные условия.
# Блок elif это тот же if, но только следующая проверка. Грубо говоря, это «а если …»
# Блоков elif может быть много.
# Блок else выполняется в том случае, если ни одно из условий if или elif не было истинным.

a = 10

if a == 10:
    print(f'{a} равно 10')
elif a < 10:
    print(f'{a} меньше 10')
else:
    print(f'{a} больше 10')

# Условия
#
# Конструкция if построена на условиях: после if и elif всегда пишется условие.
# Блоки if/elif выполняются только когда условие возвращает True,
# поэтому определимся с тем, что является истинным, а что ложным в Python.

# True и False
#
# В Python, кроме очевидных значений True и False,
# всем остальным объектам также соответствует ложное или истинное значение:
#
# истинное значение:
# - любое ненулевое число
# - любая непустая строка
# - любой непустой объект
# ложное значение:
# - 0
# - None
# - пустая строка
# - пустой объект

########################################################################################################################

# Проверить, пустой ли список, можно таким образом:
#
# 1. При помощи самого объекта

list1 = [1, 2, 3]  # или list1 = []
# если в списке есть элементы (не пустой объект это True), выполняется первое услови, второе игнорируется
if list1:
    print(f'В списке есть объекты {list1}')
# если в списке нет элементов (это False), тогда будет выполненно второе услови т.к. первое будет пропущено
else:
    print('Список пуст')

# 2. При помощи оператора сравнения.

list1 = [1, 2, 3]  # или list1 = []
# ф-я len возвращает длинну строки, если там есть элементы то она не равна (!=) 0, значит True
if len(list1) != 0:
    print(f'В списке есть объекты {list1}')
# если список пуст len вернёт 0, то вернётся False, первое условие будет пропущено и выполнится второе
else:
    print('Список пуст')

# Для проверки условий могут использоваться любые операторы сравнения ==, != <, >, =<,=>


########################################################################################################################

# При помощи операторов принадлежности in и not in
#
# Оператор in позволяет выполнять проверку на наличие элемента в последовательности
# (если элемент есть возвращается True если нет False).
# Оператор not in позволяет выполнять проверку на отсуствие элемента в последовательности
# (если элемент есть возвращается False если нет True).

# Проверка на наличие в строке (str)
intf = 'FastEthernet'
search_intf = 'Fast'
if search_intf in intf:
    print(f'"{search_intf}" найден в строке "{intf}"')
else:
    print(f'"{search_intf}" не найден в строке "{intf}"')

# Проверка на наличие в списке (list)
vlan = [10, 20, 30, 40]
vlan_id = 10
if vlan_id in vlan:
    print(f'VLAN {vlan_id} есть в списке {vlan}')
else:
    print(f'VLAN {vlan_id} не найден в списке {vlan}')

# Проверка на отсуствие в списке (list)
vlan = [10, 20, 30, 40]
vlan_id = 100
if vlan_id not in vlan:     # Если в списке отсутствует VLAN ID,
    vlan.append(vlan_id)    # то он добавляется в него
    print(f'VLAN {vlan_id} не было в спике, он был добавлен в него {vlan}')
else:
    print(f'VLAN {vlan_id} уже содержится в списке {vlan}')

# Аналогично работает с кортежами (tuple) и множествами (set)
# При использовании со словарями (dict) условие in и not in выполняет проверку только по ключам словаря
# При использовании с числами (int и float) вызывает TypeError: argument of type 'int' is not iterable


# Пример. Проверка на безопасность пароля с использованием оператора сравнения и принадлежности
username = input('Введите имя пользователя: ')
password = input('Введите пароль: ')
if len(password) < 10:      # проверка на минимальну длинну пароля
    print('Пароль слишком короткий')
elif username in password:  # проверка на совпадение логина и пароля
    print('Пароль содержит имя пользователя')
else:
    print('Пароль для пользователя {} установлен'.format(username))

########################################################################################################################

# Логические операторы and, or, not
# В Python оператор and возвращает не булево значение, а значение одного из операндов.


# Оператор and

# 1. Если оба (несколько) из операндов являются истиной, результатом выражения будет последнее истинное значение:
a = 7 and 3
print(a)  # возвращается 3 потому что оба значения (7 и 3) истинны (True), а 3 стоит последним в выражении

# 2. Если один (несколько) из операторов является ложью, результатом выражения будет первое ложное значение:
b = 7 and 0 and [] and None
print(b)  # возвращается 0 т.к. 7 истинное значение (True), а 0, [] и None ложные (False), но первое ложное значение 0

# Пример 1:
intf1 = ['switchport mode access', 'switchport access vlan 10']
intf2 = ['switchport mode trunk', 'switchport trunk allowed vlan 10']
intf3 = []

check = intf3

if check and True:
    print('Интерфейс не требует настройки')
else:
    chek = ['switchport mode access', 'switchport access vlan 10']
    print('Интерфейс был не настроен, к нему применена конфигурация:')
    print('\n'.join(chek))

# Пример 2:
intf1 = ['switchport mode access', 'switchport access vlan 10']
intf2 = ['switchport mode trunk', 'switchport trunk allowed vlan 10']
intf3 = []

check = intf1
# приоритетность такова, что вначале выполняется in а затем and: (X in Y) and (Z in W)*
if 'access' in check[0] and '10' in check[1]:
    print('Интерфейс настроен как Access для VLAN 10')
elif 'trunk' in check[0] and '10' in check[1]:
    print('Интерфейс настроен как Trunk с разрешением VLAN 10')
else:
    print('Интрефейс не настроен')

# * подробнее приоритетности операторов https://docs.python.org/3/reference/expressions.html#operator-precedence


# Оператор or

# 1. Возвращается первый истинный операнд.
a = 'str' or 100 or 1.1
print(a)  # возвращается 'str' потому что все значения (str, 10, 1.1) истинны (True), а 'str' первое из них
b = [] or 0 or 1.1 or 100
print(b)  # возвращается 1.1 потому что оно первое из двух истинных (True) значений (1.1 и 100)
c = 0 or 100
print(c)  # возвращается 100 потому что только оно истинно (True), а 0 ложно (False)

# 2. Если все значения являются ложными, возвращается последнее значение:
d = 0 or None or {} or False or '' or []
print(d)  # возвращается пустой список [] т.к. он является последним ложным значением в череде других

# ! Важная особенность работы оператора or - операнды, находящиеся после истинного, не вычисляются:
e = '' or sorted([44, 1, 67])
print(e)  # ф-я sorted вернула отсортированный список т.к. является первым истинным значение в сравненнии
f = 'str' or sorted([44, 1, 67])
print(f)  # возвращется 'str', как первое истинное значение, а ф-я sorted не была выполнена

########################################################################################################################

# Тернарное выражение (Ternary expression)

# Иногда удобнее использовать тернарный оператор, нежели развернутую форму:
s = [1, 2, 3, 4, 5]
result = True if len(s) > 5 else False
print(result)
# Этим лучше не злоупотреблять, но в простых выражениях такая запись может быть полезной.

from sys import argv

print(argv)

# argv - это список
# все аргументы находятся в списке в виде строк
# argv содержит не только аргументы, которые передали скрипту, но и название самого скрипта
#
# При запуске скрипта командой: python3 argv.py 1 2 a b
# В списке argv будут элементы: ['argv.py', '1', '2', 'a', 'b']
# Сначала идет имя/+путь самого скрипта, затем аргументы, в том же порядке.

# Пример

intf1 = argv[1]
intf2 = argv[2]
vlan = argv[3]
# Аргументы, переданы скрипту, подставляются как значения в f-строки.
access_template = [
    f'interface GigabitEthernet {intf1}/{intf2}',
    'switchport mode access',
    f'switchport access vlan {vlan}',
    'switchport nonegotiate',
    'spanning-tree portfast',
    'spanning-tree bpduguard enable'
]
# Элементы списка выводятся как отдельные строки разделённые новой строкой
print('\n'.join(access_template))


# Метод isdigit проверяет состоит ли строка из одиних цифр

str0 = '12345'.isdigit()    # Метод возвращает True т.к. в строке только числа
print(str0)
str0 = '1ъ3w5'.isdigit()    # Метод возвращает False т.к. в строке есть буквы ъ и w
print(str0)
# Пример:

input_data = input("Введите целое число: ")
if input_data.isdigit():    # == True
    output_data = int(input_data)
    print(f"Введённое число (str): '{input_data}', преобразовано в целое число (int): {output_data}")
else:
    print(f'Ошибка: \'{input_data}\' содержит недопустимые символы!')
