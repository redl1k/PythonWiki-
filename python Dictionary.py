# Словарь (Dictionary) - это изменяемый упорядоченный тип данных:

#
# данные в словаре - это пары ключ: значение
# доступ к значениям осуществляется по ключу, а не по номеру, как в списках
# данные в словаре упорядочены по порядку добавления элементов
# так как словари изменяемы, то элементы словаря можно менять, добавлять, удалять
# ключ должен быть объектом неизменяемого типа: число, строка, кортеж
# значение может быть данными любого типа
# Примечание:
# В других языках программирования может называться ассоциативный массив, хеш или хеш-таблица.

central_office = {'city': 'Moscow', 'network': '10.77.1.0 /24', 'vlan': 77, 'admin': None}

branch_office = {
    'city': 'Novosibirsk',
    'network': '10.54.1.0 /24',
    'vlan': 54,
    'admin': None
}

print(central_office, branch_office, sep='\n')

# central_office[0]  # по индексу обращатся к словарю нельзя KeyError: 0

# обращаться к значением в словаре нужно по ключам
print(central_office['city'])


# изменение значений так же происходит по ключу
branch_office['city'] = 'Omsk'
print(branch_office)


# аналогичным образом можно добавить новую пару ключ-значение
central_office['id'] = 1
branch_office['id'] = 2
print(central_office, branch_office, sep='\n')


# встроенный модуль pprint умеет выводить структуры данных в более удобнов виде
from pprint import pprint
pprint(branch_office)  # ключи в алфавитном порядке
pprint(central_office)  # длинный вывод с новой строки
# словарь внутри словаря так же выводится более удобно
routers = {
    'Router 1': {
        'hostname': 'R1',
        'model': '4451',
        'vendor': 'Cisco',
        'serial number': 'SDFHDGH1762716376312'
    },
    'Router 2': {
        'hostname': 'R2',
        'model': '4451',
        'vendor': 'Cisco',
        'serial number': 'SDFHDGH1762716376312'
    }
}
pprint(routers)
print(routers)  # обычный вывод менее читаем


# ф-ия len показывае количество пар ключ-значение в словаре
print(len(routers))


# возврат отсортированного списока из ключей
nums = {3: 10, 2: 20, 1: 30}
print(sorted(nums))


# для удаления значения из словаря используется оператор del
dict1 = {'R1': 3310, 'R2': 4010, 'R3': 1250}
del dict1['R3']
print(dict1)


# очистка содержимого словаря
dict1 = {}  # присвоением пустого значения
dict1.clear()  # методом clear


# метод get
dict1 = {'R1': 3310, 'R2': 4010, 'R3': 1250}
print(dict1['R1'])  # обращение по существующиму ключу
# print(dict1['R55'])  # обращение по не существующиму ключу KeyError: 'gdfhdsfgh'
# чтобы скрипт не остнавливался из-за ошибки можно использовать метод get
print(dict1.get('R1'))  # если ключ есть выведет возвращённое значение
print(dict1.get('R66'))  # если ключа нет, то ничего не вернёт и выведет None не вызывая ошибку

# но может возникнуть путаница
dict1 = {'R1': None, 'R2': 4010, 'R3': 1250}
print(dict1.get('R1'))  # возвращённое значаение None по существующему ключу R1 - None
print(dict1.get('R66'))  # отсуствие возвращёного значения по несуществующему ключу R66 -None
# чтобы не позникало путаницы, когда вы в словаре специально задали значение None
# можно указать что выводить если нет такого ключа
print(dict1.get('R1', 'no key'))  # т.к. ключ R1 есть получаем его значение None
print(dict1.get('R66', 'no key'))  # т.к. ключ R66 нет видим сообщение "no key"

# так же можно проверить есть ли ключ в словаре через оператор in
print("R1" in dict1)  # выведет True если такой ключ есть
print("R66" in dict1)  # выведет False если такой ключ есть


dict1 = {'R1': 2960, 'R2': 4120, 'R3': 1124}
keys = dict1.keys()      # выводит ключи словаря
vlaues = dict1.values()  # выводит значения словаря
items = dict1.items()    # выводит пары ключ - значение
print(keys, vlaues, items, sep='\n')
# при этом возвраще значения это отдельный тип данных
# который хранит ссылку на ключи, на значения и на пары ключ - значение
print(type(keys), type(vlaues), type(items), sep='\n')
# у этого типа данных есть ограничения, например нельзя обратится по индексу, хоть он и похож на список
keys_list = list(dict1.keys())  # но можно получить из него список
print(keys_list)


# метод update в обновляемый словарь добавляет не сущесвтвующие в нем пары, а существующим обновляет значения
dict1 = {'R1': 2960, 'R2': 4120, 'R3': 1124}
new = {'R1': None, 'R4': 5060}
dict1.update(new)
print(dict1)


# метод pop аналогичен по приципу методу списков: удаляет пару к-з и возвращает значение
dict1 = {'R1': 2960, 'R2': 4120, 'R3': 1124, 'R4': 5060}
delete_value = dict1.pop('R1')
print(f'из словаря {dict1} удалено значение {delete_value}')
# заменяет собой следующие две операции
dict1 = {'R1': 2960, 'R2': 4120, 'R3': 1124, 'R4': 5060}
delete_value = dict1['R1']
del dict1['R1']
print(f'из словаря {dict1} удалено значение {delete_value}')


# метод setdefault ...


# в качестве значений в словарь можно подставлять имена переменных которым присвоены значения
intf_on = ['int gi0/0', 'ip address 10.0.0.1 255.0.0.0', 'no shutdown']
intf_off = ['int gi0/0', 'no ip address', 'shutdown']
on_off = {'on': intf_on, 'off': intf_off}
print(on_off['off'])  # по ключу словаря выводим значение переменной со списком команд
print('\n'.join(on_off['off']))  # выводим команды в виде строк с новой строки


# вызов метода внутри словаря возвращает None
dict1 = {'nums': [1, 2, 3].append(100)}
print(dict1)
# следует вынести такую операцию за пределы словаря
dict1 = {'nums': [1, 2, 3]}
dict1['nums'].append(100)
print(dict1)

# ещё раз: операция присвоения значения переменно не создаёт копию данныйх, а создаёт ссылку на них
dict1 = {'nums': [1, 2, 3]}
list1 = dict1['nums']
list1.append(100)  # после этой операции
print(list1)       # изменится не только список list1
print(dict1)       # но и значение по ключу 'nums' в словаре dict1


# некоторые вещи которые можно сделать через if else возможно сделать через словарь
# так что важно выполнять задания используя только пройденные темы т.к. можно не узнать что что-то можно выполнить иначе


# Есть нескольео способов создания словарей.
# 1. при помощи литерала:
dict1 = {'key1': 'value1', 'key2': 'value2'}
print(dict1)
# 2. при помощи конструктора dict, где имена аргументов станут ключами для значений
dict1 = dict(key1='value1', key2='value2')
print(dict1)
# 3. при помощи конструткора dict и данных в виде dict_items, где пары к-з указывается в () внутри []
dict1 = dict([('R1', 2960), ('R2', 4120), ('R3', 1124)])
print(dict1)
# 4. при помощи метода fromkeys конструктора dict, если нужен словарь с ключами и пустыми или одинаковыми значениями
list_key = ['key1', 'key2', 'key3']
dict0 = dict.fromkeys(list_key)
dict1 = dict.fromkeys(list_key, 'value')
print(dict0, dict1, sep='\n')


# пример
# есть два списка содержащих значения VLAN ID с коммутаторов SW1 и SW2
# и список с сетевыми именами коммутаторов
# требуется посчитать сколько всего VALN на каждом из них и хранить эти значения
sw1_vlans = [100, 101, 102, 103, 104, 105]
sw2_vlans = [100, 101, 102, 103, 104]
hostnames = ['sw1', 'sw2']
all_vlans = dict.fromkeys(hostnames, 0)  # нужен для создания заготовки с которой будут производится дальнейшие операции
all_vlans['sw1'] += len(sw1_vlans)
all_vlans['sw2'] += len(sw2_vlans)
print(all_vlans)
