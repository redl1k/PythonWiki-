# Создание функций

#
# - функции создаются с помощью зарезервированного слова def
# - за def следуют имя функции и круглые скобки
# - внутри скобок могут указываться параметры, которые функция принимает
# - после круглых скобок идет двоеточие и с новой строки, с отступом, идет блок кода, который выполняет функция
# - первой строкой, опционально, может быть комментарий, так называемая docstring
# - в функциях может использоваться оператор return
#   - чаще всего, оператор return возвращает какое-то значение
#   - он используется для прекращения работы функции и выхода из нее

# Простой пример:
def configure_intf(intf, ip, mask):
    print('interface gigabitethernet', intf)
    print(' ip address', ip, mask)
    print(' no shutdown')


# Функция configure_intf создает конфигурацию интерфейса с указанным именем и IP-адресом.
# У функции есть три параметра: intf_num, ip, mask.

# Параметры - это переменные, которые используются при создании функции.
# Аргументы - это фактические значения (данные), которые передаются функции при вызове.

# Вызов функции
# При вызове функции нужно указать её имя и передать аргументы, если нужно.

configure_intf('0/0', '10.0.0.1', '255.255.255.0')

# Текущий вариант функции configure_intf выводит команды на стандартный поток вывода, команды можно увидеть,
# но при этом результат функции нельзя сохранить в переменную.
return_conf = configure_intf('0/0', '10.0.0.1', '255.255.255.0')
print(return_conf)

# Например, функция sorted не просто выводит результат сортировки на стандартный поток вывода,
# а возвращает его, поэтому его можно сохранить в переменную.
vlans = [100, 70, 160, 3, 600]
sort_vlans = sorted(vlans)
print(sort_vlans)


# Оператор return
#
# Чтобы функция могла возвращать какое-то значение, надо использовать оператор return.
#
# Оператор return используется для возврата какого-то значения, также он завершает работу функции.
# Функция может возвращать любой объект Python. По умолчанию, функция возвращает None.

# Пример:
def configure_intf(intf, ip, mask):
    config = f'interface gigabitethernet, {intf}\n ip address {ip}, {mask}\n no shutdown'
    return config


return_conf = configure_intf('0/0', '10.0.0.1', '255.255.255.0')
# Теперь в переменой return_conf находится строка с командами для настройки интерфейса.
print(return_conf)


# После return, функция завершает работу, а значит выражения, которые идут после return, не выполняются:
def test_funk():
    print('Строка до оператора return')
    return 'Возвращаемая функцией строка'
    print('Строка после оператора return - не будет выведена')


# Функция может возвращать несколько значений, они пишутся через запятую после оператора return.
def configure_intf(intf, ip, mask):
    config_intf = f'interface gigabitethernet {intf}'
    ip_add = f' ip address {ip} {mask}'
    intf_on = f' no shutdown'
    return config_intf, ip_add, intf_on


# При этом функция возвращает кортеж.
return_conf = configure_intf('0/0', '10.0.0.1', '255.255.255.0')
print(return_conf)

# Значения этих элементов можно присвоить различным переменным:
return_inft, return_add, return_on = configure_intf('0/0', '10.0.0.1', '255.255.255.0')
print(return_inft, return_add, return_on, sep='\n')


#######################################################################################################################

# Строки документации (docstring)

# Первая строка в определении функции - это docstring, строка документации.
# Это комментарий, который используется как описание функции:

def configure_intf(intf, ip, mask):
    """
    Сенерирует конфигурацию интерфейса
    :param intf: принимает в качестве аргумента номер интерфейса
    :param ip: принимает в качестве аргумента IP-адрес
    :param mask: принимает в качестве аргумента маску
    :return: возвращает три строки - переход в режим конфигурации интерфейса, назначение IP и маски, и включение.
    """
    config_intf = f'interface gigabitethernet {intf}'
    ip_add = f' ip address {ip} {mask}'
    intf_on = f' no shutdown'
    return config_intf, ip_add, intf_on


# Документация вызывается аналогичным образом, как и у встроенных функций.
# - вызов документации по встроенной функции:
help(print)
# - вызов документации по по нашей функции:
help(configure_intf)

# Важно писать краткие комментарии, которые описывают работу функции. Например, описать,
# что функция ожидает на вход, какого типа должны быть аргументы и что будет на выходе.
# Кроме того, лучше написать пару предложений о том, что делает функция.

#######################################################################################################################
# Создание функций https://pyneng.readthedocs.io/ru/latest/book/09_functions/create_func.html

# Пространства имен. Области видимости


# У переменных в Python есть область видимости. В зависимости от места в коде,
# где переменная была определена, определяется и область видимости, то есть,
# где переменная будет доступна.

# При использовании имен переменных в программе, Python каждый раз ищет,
# создает или изменяет эти имена в соответствующем пространстве имен.
# Пространство имен, которое доступно в каждый момент, зависит от области,
# в которой находится код.

# У Python есть правило LEGB, которым он пользуется при поиске переменных.

# Например, если внутри функции выполняется обращение к имени переменной,
# Python ищет переменную в таком порядке по областям видимости (до первого совпадения):
#   L (local) - в локальной (внутри функции)
#   E (enclosing) - в локальной области объемлющих функций (те функции, внутри которых находится наша функция)
#   G (global) - в глобальной (в скрипте)
#   B (built-in) - во встроенной (зарезервированные значения Python)

variable = 'глобальная (global) область видимости'

def main_def():
    variable = 'локальная объемлющая (enclosing) область видимости'
    def nested_def():
        variable = 'локальная (local) область видимости'
        return variable
    return nested_def

a = main_def()()
print(a)

# Соответственно, есть локальные и глобальные переменные:
#   локальные переменные:
#       - переменные, которые определены внутри функции
#       - эти переменные становятся недоступными после выхода из функции
#   глобальные переменные:
#       - переменные, которые определены вне функции
#       - эти переменные "глобальны" только в пределах модуля
#         чтобы они были доступны в другом модуле, их надо импортировать

#######################################################################################################################

# Локальные переменные недоступны в глобальной области
def test_def():
    local_variable = 10
    return local_variable
# print(local_variable)
# NameError: name 'local_variable' is not defined
# Попытка обратить к локальной переменной вызовет исключение т.к. такое имя не будет найдено

#######################################################################################################################

# global

variable = 10
# Внутри локальной области нельзя просто изменить глобальную переменную
def test_def():
    variable += 10
    return variable
# обратившись к данной функции мы получим исключение:
# UnboundLocalError: local variable 'global_variable' referenced before assignment


# Ключевое слово global позволяет изменить изнутри функции значение глобальной переменной.
def test_def():
    # Записывается перед именем переменной, которая дальше внутри функции будет считаться глобальной.
    global variable
    variable += 10
    return variable

# Теперь вызов данной функции изменит значение глобальной переменной
print(test_def())

# !!!
# Однако менять значение глобальной переменной изнутри функции не стоит, это ухудшает читаемость кода.
# Чем меньше то, что происходит внутри функции будет зависеть от глобальной области видимости, тем лучше

#######################################################################################################################

# nonlocal

# Внутри локальной области вложенной функции так же нельзя просто изменить "нелокальную" переменную
def test_def2():
    local_variable = 10
    def in_test_def():
        local_variable += 10
        return local_variable
    return in_test_def
# обратившись к данной функции мы получим исключение:
# UnboundLocalError: local variable 'local_variable' referenced before assignment


# nonlocal позволяет изменить изнутри вложенной функции значение переменной из области основной функции.
def test_def2():
    local_variable = 10
    def in_test_def():
        nonlocal local_variable
        local_variable += 10
        return local_variable
    return in_test_def

# Теперь вызов данной функции изменит значение "нелокальной" переменной
print(test_def2()())

#######################################################################################################################

# В качестве вывода можно сформулировать несколько правил:
#
# - Изнутри функции видны переменные, которые были определены и внутри нее и снаружи.
#   Переменные, определенные внутри – локальные, снаружи – глобальные.
# - Снаружи функций не видны никакие переменные, определенные внутри них.
# - Изнутри функции можно изменять значение переменных, которые определены в глобальной
#   области видимости с помощью спецификатора global.
# - Изнутри вложенной функции с помощью спецификатора nonlocal можно изменять значения переменных,
#   которые были определены во внешней функции, но не находятся в глобальной области видимости.